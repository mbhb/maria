#include <stdio.h>
#include <unistd.h>
#include <netdb.h>
#include <sys/types.h>
#include <string.h>
#include <sys/socket.h>
#include <time.h>
#include <signal.h>
#include <sys/wait.h>

#define MAX_CHILDREN 5  // Número máximo de procesos hijos

void handle_signal(int signo)
{
    // Manejar la señal SIGTERM
    if (signo == SIGTERM)
    {
        printf("Recibida señal SIGTERM. Terminando...\n");
        _exit(0);
    }
}

int main(int argc, char **argv)
{
    if (argc < 3)
    {
        printf("Error en los argumentos\n");
        return -1;
    }

    struct addrinfo hints;
    struct addrinfo *resul;

    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_flags = AI_PASSIVE;
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;

    int rc = getaddrinfo(argv[1], argv[2], &hints, &resul);
    if (rc != 0)
    {
        perror("error \n");
        return -1;
    }

    int sd = socket(resul->ai_family, resul->ai_socktype, 0);
    int a = bind(sd, resul->ai_addr, resul->ai_addrlen);
    if (a == -1)
    {
        perror("Error: \n");
        return -1;
    }

    freeaddrinfo(resul);

    // Configurar el manejo de la señal SIGTERM
    signal(SIGTERM, handle_signal);

    // Crear procesos hijos
    for (int i = 0; i < MAX_CHILDREN; ++i)
    {
        pid_t pid = fork();

        if (pid == 0)
        {
            // Código del proceso hijo
            while (1)
            {
                char buffer[100];
                char host[NI_MAXHOST];
                char serv[NI_MAXSERV];
                struct sockaddr_storage cliente;
                socklen_t clientelen = sizeof(struct sockaddr_storage);

                int bytes = recvfrom(sd, buffer, 99, 0, (struct sockaddr *)&cliente, &clientelen);
                buffer[bytes] = '\0';
                getnameinfo((struct sockaddr *)&cliente, clientelen, host, NI_MAXHOST, serv, NI_MAXSERV, 0);

                printf("Proceso %d: %i bytes de %s:%s\n", getpid(), bytes, host, serv);

                char t[] = "t";
                char q[] = "q";
                char d[] = "d";
                char f[64];

                if (q[0] == buffer[0])
                {
                    printf("Saliendo...\n");
                    close(sd);
                    break;
                }
                else
                {
                    time_t now;
                    struct tm *tm;

                    now = time(NULL);
                    tm = localtime(&now);

                    if (d[0] == buffer[0])
                    {
                        int y = strftime(f, sizeof(f), "%x", tm);
                        f[y] = '\0';
                        sendto(sd, f, y, 0, (struct sockaddr *)&cliente, clientelen);
                    }
                    else if (t[0] == buffer[0])
                    {
                        int y = strftime(f, sizeof(f), "%c", tm);
                        f[y] = '\0';
                        sendto(sd, f, y, 0, (struct sockaddr *)&cliente, clientelen);
                    }
                    else
                    {
                        printf("Comando %s no soportado\n", buffer);
                    }
                }
            }
            // Salir del bucle del hijo
            _exit(0);
        }
        else if (pid < 0)
        {
            perror("Error al crear el proceso hijo\n");
            return -1;
        }
    }

    // Código del proceso padre
    // El proceso padre simplemente espera a que todos los hijos terminen
    for (int i = 0; i < MAX_CHILDREN; ++i)
    {
        wait(NULL);
    }

    return 0;
}


