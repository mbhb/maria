#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netdb.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h> 
#include <unistd.h>
#include <sys/wait.h>



#define BUF_SIZE 500

void child(int s){
    while(waitpid(0,NULL,WNOHANG)!=-1){};

}

int main(int argc, char *argv[]){
    struct sigaction sa;
    sa.sa_handler=child;
    sa.sa_flags=SA_RESTART;
    sigaction(SIGCHLD,&sa,0);

    struct addrinfo hints;
    struct addrinfo *result;
    int s, sfd;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */
    hints.ai_protocol = 0;          /* Any protocol */
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;

    s = getaddrinfo(argv[1], argv[2], &hints, &result);
    if (s != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
        exit(EXIT_FAILURE);
    }

    sfd = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
if (sfd == -1) {
    perror("socket");
    exit(EXIT_FAILURE);
}

if (bind(sfd, result->ai_addr, result->ai_addrlen) != 0) {
    perror("bind");
    exit(EXIT_FAILURE);
}

    freeaddrinfo(result);   
    // Crear procesos hijos
    for (int i = 0; i < 5; ++i)
    {
        pid_t pid = fork();

        if(pid==0){
            while(1){
                struct sockaddr_storage peer_addr;
                socklen_t peer_addr_len;
                char buf[BUF_SIZE];

                peer_addr_len = sizeof(peer_addr);
                int nread = recvfrom(sfd, buf, BUF_SIZE, 0,(struct sockaddr *) &peer_addr, &peer_addr_len);

                char host[NI_MAXHOST], service[NI_MAXSERV];

                s = getnameinfo((struct sockaddr *) &peer_addr, peer_addr_len, host, NI_MAXHOST,service, NI_MAXSERV,NI_NUMERICHOST);
                printf("Received %d bytes from %s:%s %d\n", nread, host, service, getpid());


                char t[]="t";
                char q[]="q";
                char d[]="d";
                if(q[0]==buf[0]){
                    printf("Saliendo...\n");
                    close(sfd);
                    break;
                }else{
                    char outstr[200];
                    time_t ti;
                    struct tm *tmp;

                ti = time(NULL);
                tmp = localtime(&ti);

                if(d[0]==buf[0]){
                        int datos= strftime(outstr, sizeof(outstr), "%x", tmp);
                        outstr[datos]='\0';
                        sendto(sfd, outstr, strlen(outstr), 0,(struct sockaddr *) &peer_addr,peer_addr_len);
                    }
                    if (t[0] == buf[0]) {
                        int datos= strftime(outstr, sizeof(outstr), "%c", tmp);
                        outstr[datos]='\0';
                        sendto(sfd, outstr, strlen(outstr), 0,(struct sockaddr *) &peer_addr,peer_addr_len);
                    }


                }

            }
            close(sfd);
            return 0;
        }
    }
    close(sfd);
    return 0;
}

o

#include <stdio.h>
#include <signal.h>
#include <netdb.h>
#include <sys/types.h>
#include <string.h>
#include <sys/socket.h>
#include <time.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int operativa(int *sd){
        char buffer[100];
        char host[NI_MAXHOST];
        char serv[NI_MAXSERV];
        struct sockaddr_storage cliente;
        socklen_t clientelen=sizeof(struct sockaddr_storage);
        int bytes=recvfrom(*sd,buffer,99,0,(struct sockaddr*)&cliente,
        &clientelen);
        if(bytes!=0){
            
        
        buffer[bytes]='\0';
        getnameinfo((struct sockaddr*)&cliente,clientelen,host,NI_MAXHOST,serv,NI_MAXSERV,0);
        printf("[PID:%i] %i bytes de %s:%s\n",getpid(),bytes,host,serv);
        char t[]="t";
        char q[]="q";
        char d[]="d";
        if(q[0]==buffer[0]){
            printf("Saliendo...\n");
            close(*sd);
            return -1;
        }else{
            time_t now;
            struct tm *tm;
       
            now = time(NULL);
            tm = localtime(&now);
            char f[100];
         
        if(d[0]==buffer[0]){
            int y=strftime(f, sizeof(f), "%x", tm);
            f[y]='\0';
            sendto(*sd,f,y,0,(struct sockaddr*)&cliente,clientelen);
        }else{
        if(t[0]==buffer[0]){
             int y=strftime(f, sizeof(f), "%c", tm);
             f[y]='\0';
             sendto(*sd,f,y,0,(struct sockaddr*)&cliente,clientelen);
            
        }else{
            printf("Comando %s no soportado\n",buffer);
        }
        }
            
        }
        }

        return 0;
}
void child(int s){
    while(waitpid(0,NULL,WNOHANG)!=-1){};

}

int main(int argc, char **argv)
{   
    struct sigaction sa;
    sa.sa_handler=child;
    sa.sa_flags=SA_RESTART;
    sigaction(SIGCHLD,&sa,0);
    if(argc<3){
        printf("Errror en los argumentos\n");
        return -1;
    }
     struct addrinfo hints;
    struct addrinfo *resul;
    memset(&hints,0,sizeof(struct addrinfo));
    hints.ai_flags=AI_PASSIVE;
    hints.ai_family=AF_UNSPEC;
    hints.ai_socktype=SOCK_DGRAM;
    int rc=getaddrinfo(argv[1],argv[2],&hints,&resul);
    if(rc!=0){
        perror("error \n");
        return -1;
    }
    int sd=socket(resul->ai_family,resul->ai_socktype,0);
    int a=bind(sd,resul->ai_addr,resul->ai_addrlen);
    if(a==-1){
        perror("Error: \n");
        return -1;
    }
    freeaddrinfo(resul);
    int i=0;
    for(i=0;i<5;i++){
    pid_t pid=fork();
    
        if(pid==0){
            
            while(1){
                
                int y=operativa(&sd);
                if(y==-1){ break;}
                
            }
                close(sd);
                return 0;
        }else{
                
               
        }
    }
    close(sd);
return 0;
}




