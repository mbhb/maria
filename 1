/*Ejercicio 1. Escribir un programa que obtenga todas las posibles direcciones con las que se podría crear un socket asociado a un 
host dado como primer argumento del programa. Para cada dirección, mostrar la IP numérica, la familia de protocolos y tipo de socket. Comprobar el resultado para:
Una dirección IPv4 válida (ej. “147.96.1.9”).
Una dirección IPv6 válida (ej. “fd00::a:0:0:0:1”).
Un nombre de dominio válido (ej. “www.google.com”).
Un nombre en /etc/hosts válido (ej. “localhost”).
Una dirección o nombre incorrectos en cualquiera de los casos anteriores.
El programa se implementará usando getaddrinfo(3) para obtener la lista de posibles direcciones de socket (struct sockaddr). 
Cada dirección se imprimirá en su valor numérico, usando getnameinfo(3) 
con el flag NI_NUMERICHOST, así como la familia de direcciones y el tipo de socket.
Para probar el comportamiento con DNS, realizar este ejercicio en la máquina física.*/

#include <stdio.h>
#include <sys/socket.h>
#include <netdb.h>
#include <sys/types.h>
#include <string.h>

int main(int argc, char **argv) {
    // Verificación de la cantidad de argumentos
    if (argc < 3) {
        printf("Error en los argumentos\n");
        return -1;
    }

    // Estructura para configurar la búsqueda de información de dirección
    struct addrinfo hints;
    // Puntero para almacenar los resultados obtenidos por getaddrinfo
    struct addrinfo *resul;

    // Inicializar la estructura hints a cero y configurar los parámetros
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_flags = AI_PASSIVE;  // Para dirección IP comodín
    hints.ai_family = AF_UNSPEC;  // Permite IPv4 o IPv6
    hints.ai_socktype = SOCK_STREAM;  // Tipo de socket: SOCK_STREAM (TCP)

    // Obtener información de dirección para el socket
    int rc = getaddrinfo(argv[1], argv[2], &hints, &resul);
    if (rc != 0) {
        perror("Error al obtener información de dirección");
        return -1;
    }

    // Iterar sobre la lista de resultados obtenidos por getaddrinfo
    for (struct addrinfo *i = resul; i != NULL; i = i->ai_next) {
        char host[NI_MAXHOST];
        char serv[NI_MAXSERV];

        // Obtener información numérica de la dirección
        getnameinfo(i->ai_addr, i->ai_addrlen, host, NI_MAXHOST, serv, NI_MAXSERV, NI_NUMERICHOST | NI_NUMERICSERV);

        // Imprimir información sobre la dirección
        printf("%s %s %i %i\n", host, serv, i->ai_family, i->ai_socktype);
    }

    // Liberar la memoria utilizada por getaddrinfo
    freeaddrinfo(resul);

    return 0;
}
