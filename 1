/*Ejercicio 1. Escribir un programa que obtenga todas las posibles direcciones con las que se podría crear un socket asociado a un 
host dado como primer argumento del programa. Para cada dirección, mostrar la IP numérica, la familia de protocolos y tipo de socket. Comprobar el resultado para:
Una dirección IPv4 válida (ej. “147.96.1.9”).
Una dirección IPv6 válida (ej. “fd00::a:0:0:0:1”).
Un nombre de dominio válido (ej. “www.google.com”).
Un nombre en /etc/hosts válido (ej. “localhost”).
Una dirección o nombre incorrectos en cualquiera de los casos anteriores.
El programa se implementará usando getaddrinfo(3) para obtener la lista de posibles direcciones de socket (struct sockaddr). 
Cada dirección se imprimirá en su valor numérico, usando getnameinfo(3) 
con el flag NI_NUMERICHOST, así como la familia de direcciones y el tipo de socket.
Para probar el comportamiento con DNS, realizar este ejercicio en la máquina física.*/

#include <stdio.h>
#include <sys/socket.h>
#include <netdb.h>
#include <sys/types.h>
#include <string.h>

int main(int argc, char **argv)
{
    // Verifica que se proporcionen al menos dos argumentos (nombre del programa y nombre de host/servicio).
    if (argc < 3) {
        printf("Error en los argumentos\n");
        return -1;
    }

    // Estructura para especificar criterios en getaddrinfo.
    struct addrinfo hints;

    // Estructura para almacenar los resultados de getaddrinfo.
    struct addrinfo *result;

    // Limpia la estructura hints.
    memset(&hints, 0, sizeof(struct addrinfo));

    // Configura los criterios para obtener direcciones de cualquier familia (IPv4 o IPv6),
    // tipo de socket stream y flags AI_PASSIVE (para uso en bind).
    hints.ai_flags = AI_PASSIVE;
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    // Llama a getaddrinfo para obtener la información sobre la dirección y el servicio especificados.
    int rc = getaddrinfo(argv[1], argv[2], &hints, &result);
    if (rc != 0) {
        perror("Error en getaddrinfo: ");
        return -1;
    }

    // Itera a través de los resultados obtenidos.
    for (struct addrinfo *i = result; i != NULL; i = i->ai_next) {
        char host[NI_MAXHOST];
        char serv[NI_MAXSERV];

        // Obtiene información legible sobre la dirección y el servicio.
        getnameinfo(i->ai_addr, i->ai_addrlen, host, NI_MAXHOST, serv, NI_MAXSERV, NI_NUMERICHOST | NI_NUMERICSERV);

        // Imprime la información obtenida.
        printf("%s %s %i %i\n", host, serv, i->ai_family, i->ai_socktype);
    }

    // Libera la memoria reservada por getaddrinfo.
    freeaddrinfo(result);

    return 0;
}
