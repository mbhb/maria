/*Ejercicio 1. Escribir un programa que emule el comportamiento de la shell en la ejecución de una sentencia en la forma: comando1 argumento1 | comando2 argumento2. El programa creará una tubería sin nombre y creará un hijo:
El proceso padre redireccionará la salida estándar al extremo de escritura de la tubería y ejecutará comando1 argumento1.
El proceso hijo redireccionará la entrada estándar al extremo de lectura de la tubería y ejecutará comando2 argumento2.
Probar el funcionamiento con una sentencia similar a: ./ejercicio1 echo 12345 wc -c
Nota: Antes de ejecutar el comando correspondiente, deben cerrarse todos los descriptores no necesarios.*/
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[]){

    int pipe_fd[2];

    if (pipe(pipe_fd) == -1) {
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    pid_t pid = fork();
    /*El proceso hijo redireccionará la entrada estándar al extremo de lectura de la tubería y ejecutará comando2 argumento2.*/
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    //proceso hijo
    if(pid==0){
         // Cerrar el extremo de escritura de la tubería en el proceso hijo
        close(pipe_fd[1]);

        // Redireccionar la entrada estándar al extremo de lectura de la tubería
        dup2(pipe_fd[0], STDIN_FILENO);

        // Cerrar descriptores no necesarios
        close(pipe_fd[0]);

        // Ejecutar el segundo comando con sus argumentos
        execvp(argv[3], &argv[3]);

        // En caso de error en execvp
        perror("Error al ejecutar comando2");
        exit(EXIT_FAILURE);
    }
    //proceso padre
    else{
        // Cerrar el extremo de lectura de la tubería en el proceso padre
        close(pipe_fd[0]);

        // Redireccionar la salida estándar al extremo de escritura de la tubería
        dup2(pipe_fd[1], STDOUT_FILENO);

        // Cerrar descriptores no necesarios
        close(pipe_fd[1]);

        // Ejecutar el primer comando con sus argumentos
        execvp(argv[1], &argv[1]);

        // En caso de error en execvp
        perror("Error al ejecutar comando1");
        exit(EXIT_FAILURE);
    }
    return 0;
}
otra:
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>



int main(int argc, char *argv[]){
    int pipefd[2];
    pid_t cpid;
    pipe(pipefd);
    cpid=fork();
    char *c1[]={argv[1],argv[2],NULL};
    char *c2[]={argv[3],argv[4],NULL};

    if (cpid==0){
        printf("hijo\n");
        close(pipefd[1]);
        dup2(STDIN_FILENO, pipefd[0]);
        execvp(c2[0],c2);
        close(pipefd[0]);
        _exit(EXIT_SUCCESS);

    }
    else{
        printf("papa\n");
        close(pipefd[0]);
        dup2(STDIN_FILENO, pipefd[1]);
        execvp(c1[0],c1);
        close(pipefd[1]);
        wait(NULL);                /* Wait for child */
        exit(EXIT_SUCCESS);

    }

}
