/*Ejercicio 2. Para la comunicación bi-direccional, es necesario crear dos tuberías, una para cada sentido: p_h y h_p. 
Escribir un programa que implemente el mecanismo de sincronización de parada y espera:
El padre leerá de la entrada estándar (terminal) y enviará el mensaje al proceso hijo, escribiéndolo en la tubería p_h. 
Entonces permanecerá bloqueado esperando la confirmación por parte del hijo en la otra tubería, h_p.
El hijo leerá de la tubería p_h, escribirá el mensaje por la salida estándar y esperará 1 segundo. 
Entonces, enviará el carácter ‘l’ al proceso padre, escribiéndolo en la tubería h_p, para indicar que está listo. 
Después de 10 mensajes enviará el carácter ‘q’ para indicar al padre que finalice.*/
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>



int main(int argc, char *argv[]){
    
    char buf;
    int p_h[2];
    int h_p[2];
    pid_t cpid;
    pipe(p_h);
    pipe(h_p);
    cpid=fork();

    if (cpid==0){
         char message[100];
        close(p_h[1]);
        close(h_p[0]);
        int mensaje=0;
        while (mensaje<10){
            ssize_t bytes=read(p_h[0], message, sizeof(message));
            write(STDOUT_FILENO,message, bytes);
            sleep(1);
            write(h_p[1], "1", 1);
            mensaje++;
        }
         write(h_p[1], "q", 1);

        close(p_h[0]);
        close(h_p[1]);

        _exit(EXIT_SUCCESS);

    }
    else{
        close(p_h[0]);
        close(h_p[1]);
        char message[100];
        char ge='-';
        while(ge!='q')
        {
            ssize_t bytes=read(STDIN_FILENO, message, sizeof(message));
            write(p_h[1], message, sizeof(message));
            read(h_p[0], &ge, 1);
        }

        close(p_h[1]);
        close(h_p[0]);
        wait(NULL);                /* Wait for child */
        exit(EXIT_SUCCESS);

    }

}
