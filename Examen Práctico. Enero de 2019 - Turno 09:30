1.
  Las dos primeras partes easy.
  Tercera parte: ubuntu@ubuntu-jammy:~$ sudo iptables -t nat -A POSTROUTING -o enp0s8 -j MASQUERADE
                 ubuntu@ubuntu-jammy:~$ sudo iptables -t nat -L
2.RECUERDA LA \N
  #include <sys/types.h>
  #include <sys/wait.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  
  int main(int argc, char *argv[]) {
      int pid = fork();
      if (pid == 0) {
          setsid();
          chdir("/tmp");
          printf("datos: %d %d %d %d\n", getpid(), getppid(), getpgid(getpid()), getsid(0));
          execvp(argv[1], &argv[1]);
      } else {
          waitpid(pid, NULL, 0);
          return 0;
      }
  }

3. RECUERDA NI_NUMERICHOST, Y++ E I Y OUTS....
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netdb.h>
#include <time.h>


#define BUF_SIZE 500

int main(int argc, char *argv[])
{
    struct addrinfo hints;
    struct addrinfo *result;
    int sfd, s;
    struct sockaddr_storage peer_addr;
    socklen_t peer_addr_len;
    ssize_t nread;
    char buf[BUF_SIZE];

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */
    hints.ai_protocol = 0;          /* Any protocol */
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;

    s = getaddrinfo(argv[1], argv[2], &hints, &result);
    if (s != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
        exit(EXIT_FAILURE);
    }
    sfd = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
    bind(sfd, result->ai_addr, result->ai_addrlen) ;
    
    freeaddrinfo(result);           /* No longer needed */

    for (;;) {
        char outstr[64];
        time_t t;
        struct tm *tmp;

        t = time(NULL);
        tmp = localtime(&t);

        peer_addr_len = sizeof(peer_addr);
        nread = recvfrom(sfd, buf, BUF_SIZE, 0,(struct sockaddr *) &peer_addr, &peer_addr_len);
        buf[nread] = '\0';
        if(nread>0){char host[NI_MAXHOST], service[NI_MAXSERV];
        s = getnameinfo((struct sockaddr *) &peer_addr,peer_addr_len, host, NI_MAXHOST,service, NI_MAXSERV, NI_NUMERICHOST);
        printf("Received %zd bytes from %s:%s\n", nread, host, service);
        
        int y=strftime(outstr, sizeof(outstr), "%c" , tmp);
        outstr[y] = '\0';
        outstr[y++] = '\n';
        sendto(sfd, outstr, y+1, 0, (struct sockaddr *) &peer_addr,peer_addr_len);
        }

    }
    close(sfd);
    return 0;
}
2.RECUERDA /N EN EL PRINTF
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>




int main(int argc, char *argv[]){
    int pid= fork();
    switch(pid){
        case 0:
        setsid();
        chdir("/tmp");
        printf("id_proceso%d,padre%d,grupo%d,padre_grupo%d,sesion%d\n",getpid(),getppid(),getpgid(getpid()),getsid(getpid()));
        execvp(argv[1], &argv[1]);
        break;
        default:
        sleep(10);
        break;
    }
    return 0;
}

