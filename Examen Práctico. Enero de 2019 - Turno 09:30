1.
  Las dos primeras partes easy.
  Tercera parte: ubuntu@ubuntu-jammy:~$ sudo iptables -t nat -A POSTROUTING -o enp0s8 -j MASQUERADE
                 ubuntu@ubuntu-jammy:~$ sudo iptables -t nat -L
2.RECUERDA LA \N
  #include <sys/types.h>
  #include <sys/wait.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
  
  int main(int argc, char *argv[]) {
      int pid = fork();
      if (pid == 0) {
          setsid();
          chdir("/tmp");
          printf("datos: %d %d %d %d\n", getpid(), getppid(), getpgid(getpid()), getsid(0));
          execvp(argv[1], &argv[1]);
      } else {
          waitpid(pid, NULL, 0);
          return 0;
      }
  }

3. RECUERDA NI_NUMERICHOST, Y++ E I Y OUTS....
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netdb.h>
#include <time.h>


#define BUF_SIZE 500

int main(int argc, char *argv[])
{
    struct addrinfo hints;
    struct addrinfo *result;
    int sfd, s;
    struct sockaddr_storage peer_addr;
    socklen_t peer_addr_len;
    ssize_t nread;
    char buf[BUF_SIZE];

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */
    hints.ai_protocol = 0;          /* Any protocol */
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;

    s = getaddrinfo(argv[1], argv[2], &hints, &result);
    if (s != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(s));
        exit(EXIT_FAILURE);
    }
    sfd = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
    bind(sfd, result->ai_addr, result->ai_addrlen) ;
    
    freeaddrinfo(result);           /* No longer needed */

    for (;;) {
        char outstr[64];
        time_t t;
        struct tm *tmp;

        t = time(NULL);
        tmp = localtime(&t);

        peer_addr_len = sizeof(peer_addr);
        nread = recvfrom(sfd, buf, BUF_SIZE, 0,(struct sockaddr *) &peer_addr, &peer_addr_len);
        buf[nread] = '\0';
        if(nread>0){char host[NI_MAXHOST], service[NI_MAXSERV];
        s = getnameinfo((struct sockaddr *) &peer_addr,peer_addr_len, host, NI_MAXHOST,service, NI_MAXSERV, NI_NUMERICHOST);
        printf("Received %zd bytes from %s:%s\n", nread, host, service);
        
        int y=strftime(outstr, sizeof(outstr), "%c" , tmp);
        outstr[y] = '\0';
        outstr[y++] = '\n';
        sendto(sfd, outstr, y+1, 0, (struct sockaddr *) &peer_addr,peer_addr_len);
        }

    }
    close(sfd);
    return 0;
}
2.RECUERDA /N EN EL PRINTF
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>




int main(int argc, char *argv[]){
    int pid= fork();
    switch(pid){
        case 0:
        setsid();
        chdir("/tmp");
        printf("id_proceso%d,padre%d,grupo%d,padre_grupo%d,sesion%d\n",getpid(),getppid(),getpgid(getpid()),getsid(getpid()));
        execvp(argv[1], &argv[1]);
        break;
        default:
        sleep(10);
        break;
    }
    return 0;
}
3. //RECUERDA EL STRLEN
SIN MULTIPLESACIÓN:
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netdb.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>



#define BUF_SIZE 500

int main(int argc, char *argv[])
{
    struct addrinfo hints;
    struct addrinfo *result;
    int sfd;
    struct sockaddr_storage peer_addr;
    socklen_t peer_addr_len;
    ssize_t nread;
    char buf[BUF_SIZE];
    
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */
    hints.ai_protocol = 0;          /* Any protocol */
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;

    getaddrinfo(argv[1], argv[2], &hints, &result);

    sfd = socket(result->ai_family, result->ai_socktype,result->ai_protocol);
    bind(sfd, result->ai_addr, result->ai_addrlen);
    //close(sfd);
    freeaddrinfo(result);           

    while(1) {
        char outstr[200];
        time_t t;
        struct tm *tmp;

        t = time(NULL);
        tmp = localtime(&t);
        strftime(outstr, sizeof(outstr), "%Y-%m-%d %H:%M:%S", tmp);


        peer_addr_len = sizeof(peer_addr);
        if((nread = recvfrom(sfd, buf, BUF_SIZE, 0,(struct sockaddr *) &peer_addr, &peer_addr_len))>0){
            char host[NI_MAXHOST], service[NI_MAXSERV];
            getnameinfo((struct sockaddr *) &peer_addr,peer_addr_len, host, NI_MAXHOST, service, NI_MAXSERV, NI_NUMERICHOST);
            printf("from %s:%s\n", host, service);
            sendto(sfd, outstr, strlen(outstr), 0,(struct sockaddr *) &peer_addr, peer_addr_len);//RECUERDA EL STRLEN
        }
    }
}

3.
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netdb.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>



#define BUF_SIZE 500

int main(int argc, char *argv[])
{
    struct addrinfo hints;
    struct addrinfo *result;
    int sfd;
    struct sockaddr_storage peer_addr;
    socklen_t peer_addr_len;
    ssize_t nread;
    char buf[BUF_SIZE];
    
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */
    hints.ai_protocol = 0;          /* Any protocol */
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;

    getaddrinfo(argv[1], argv[2], &hints, &result);

    sfd = socket(result->ai_family, result->ai_socktype,result->ai_protocol);
    bind(sfd, result->ai_addr, result->ai_addrlen);
    //close(sfd);
    freeaddrinfo(result);           

    while(1) {
        fd_set rfds;
        char outstr[200];
        time_t t;
        struct tm *tmp;

        FD_ZERO(&rfds);
        FD_SET(0, &rfds);
        FD_SET(sfd, &rfds);
        select(sfd+1, &rfds, NULL, NULL, NULL);


        t = time(NULL);
        tmp = localtime(&t);
        strftime(outstr, sizeof(outstr), "%Y-%m-%d %H:%M:%S", tmp);

         if (FD_ISSET(sfd, &rfds)){
            peer_addr_len = sizeof(peer_addr);
            if((nread = recvfrom(sfd, buf, BUF_SIZE, 0,(struct sockaddr *) &peer_addr, &peer_addr_len))>0){
                char host[NI_MAXHOST], service[NI_MAXSERV];
                getnameinfo((struct sockaddr *) &peer_addr,peer_addr_len, host, NI_MAXHOST, service, NI_MAXSERV, NI_NUMERICHOST);
                printf("from %s:%s\n", host, service);
                sendto(sfd, outstr, strlen(outstr), 0,(struct sockaddr *) &peer_addr, peer_addr_len);//RECUERDA EL STRLEN
                
            }
         }
         if (FD_ISSET(0, &rfds)) {
            char c;
            // Leer todos los caracteres pendientes en la entrada estándar
            while (read(0, &c, 1) > 0) {
                if (c == '\n') {
                    break;
                }
            }
            printf("hora %s\n", outstr);
        }
    }

    return 0;
}


