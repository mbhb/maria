#include <iostream>
#include <string>
using namespace std;

int longitud(unsigned long long int n) {
	int salida = 0;
	while (n != 0) {
		n /= 10;
		salida++;
	}
	return salida;
} //Devuelve la longitud de un nï¿½mero

unsigned long long int pot(int n, int e) {
	unsigned long long int salida = 1;
	for (int i = 0; i < e; i++) {
		salida *= n;
	}
	return salida;
} //Devuelve n^e

//Recursion lineal
//Coste: Orden(longtitud(n))
//{ 0 <= n <= 10^18}
// fun withoutOnes(n: ent) dev r: ent
unsigned long long int withoutOnes(unsigned long long int n) {
	//t(n) = longitud(n)
	if (n == 0) { //Caso base 0: return 1
		return 1;
	}
	else if (n < 10) { //Caso base n < 10: return n
		return n;
	}
	else { //Caso Base
		int tamanno = longitud(n); 
		unsigned long long int potencia = pot(10, tamanno - 1);
		int primerDig = n / potencia;
		if (primerDig == 1) { //Caso n_(longitud(n)) == 1
			return (unsigned long long int)pot(9, tamanno - 1); //return 9^(longitud(n)-1)
		}
		else { //Caso recursivo
			return (unsigned long long int)(primerDig - 1)*pot(9, tamanno - 1) + withoutOnes(n - primerDig * potencia);
			//return (n_(longitud(n) - 1)*9^(longitud(n) - 1) + withoutOnes(n - n_(longitud(n)) * 10^(longitud(n) - 1)) 
		}
	}
}
//Sabemos que todo numero se puede descomponer de la forma sum i : 0 <= i <= longitud : b_i*10^(i). Tomaremos esos b_i en la postcondicion.
//{r = # k : 0 <= k <= n : (p.t. i : 0 <= i <= longitud : b_i != 1)}

bool resuelveCaso() {
	unsigned long long int n;
	cin >> n;
	if (!std::cin) // fin de la entrada
		return false;
	cout << withoutOnes(n) << endl;
	return true;
}
int main() {
	while (resuelveCaso());
	return 0;
}
